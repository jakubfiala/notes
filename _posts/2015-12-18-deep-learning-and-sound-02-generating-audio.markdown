---
layout: post
title:  "Deep Learning and Sound ~ 02: Generating Audio"
date:   2015-12-18 19:00:00 +0000
categories: deep-learning, sound, machine-learning, composition, lstm, neural-networks
---

![](img/dls_02/code.png)

So in the [last post,](/notes/deep-learning-and-sound-01-intro){:target="_blank"} I've discussed the background and goals of my research. I've talked about GRUV, a system which [kind of achieves](https://www.youtube.com/watch?v=0VTI1BBLydE){:target="_blank"} exactly what I'm aiming at. However, I found that the audio generated by the GRUV method has several problems, such as lack of long-term development, noisiness, etc. Today I'm going to show a few examples of what my system, which is currently very similar to GRUV, generates while being trained on various experimental datasets.

## Tech setup

For my deep learning experiments, I've used a handful of toolkits. Coming from a JS-heavy background, I first worked with [convnet.js](http://cs.stanford.edu/people/karpathy/convnetjs/){:target="_blank"} by A. Karpathy, with which I made quick small systems capable of stuff like segmenting an audio file based on MFCCs, and learning the mapping of MFCC values to position in the file. This is already a useful thing, as it can be used for a sort of concatenative synthesis, based on the desired MFCC values. I'm super interested in developing a recurrent model which could learn sequences of MFCC frames and resynthesize audio based on a generated sequence.

However, I quickly found that node just doesn't provide a good performance when working with bigger models and high-dimensional input, e.g. CNNs for decent resolution images or WAV audio.

That's why I transferred to __[keras,](http://keras.io){:target="_blank"}__ a very versatile library built on top of Theano, which has one _massive_ advantage – __GPU support!!!__ It's also the library that GRUV is using. It's reasonably fast, and the API is really well laid-out, albeit (I feel) not comprehensively documented. But because it's python, and python is awesome, and python has numpy, and python has `python -i`, it's also awesome.

I found that using GPU-accelerated Theano in keras reduces training time by ~50%, and that's on an integrated GPU in a 6-years-old Macbook.


## The Model

There is a general consensus in the deep learning community that LSTM networks are currently the most effective RNN architecture for unsupervised learning of time series. So this type of RNN was naturally my first choice for experimenting with audio generation.

Inspired by the GRUV method discussed in the [previous post,](/deep-learning-and-sound-01-intro/){:target="_blank"} I've set up a keras script for each step of the process – pre-processing, training, and generation. Initially, I started with a method nearly identical to GRUV, where each training example would be a sequence of _M_ timesteps, each of size _N._ Each timestep would be created by selecting a corresponding chunk of audio, taking the FFT (Fast Fourier Transform, output size _N/2_) and concatenating its real and imaginary parts as a real-valued numpy array of length _N._ This supposedly focuses the LSTM on the frequency content of the sound, which may or may not be an advantage – however, since we effectively double up the FFT output, we are left with the same dimensionality as if we simply trained on raw audio signal.

In addition to storing the frames themselves, I've also kept track of the overall mean and variance of the entire sequence, as per Nayebi et al.[^1], and added it back to the generated frames afterwards. This is a good way of only giving the model the bits of sound that change a lot.

I've stacked several LSTM layers, also of size _N,_ and wrapped them in the keras `TimeDistributedDense` layers, which are advantageous because they apply the same function to each timestep in the input sequence, which means fewer neurons are needed.

## Experiments

So with this fairly comprehensive architecture, I trained the model on a single recording of me singing some vowels in a constant pitch. This obviously had to lead to overfitting, but as a mere test, it should be fine.

I then had the model predict the next frame based on a "seed frame". The output was recorded, and appended to the seed, resulting in a longer sequence. After a certain number of iterations, the recorded frames were dumped to a WAV file, which pretty much all the way through looked like this:

<br>
![](img/dls_02/gen1.png)
_Note: I'm not really into soundcloud, and Freesound takes quite a while to moderate submissions, so I don't have playable embeds of all the files yet. If you know of a good free audio hosting service, please let me know on twitter, I'll buy you a pint or two._
<br>

Now, that does kind of look like a vowel sound – except that, it never changes. There were 4 different vowels in the source recording, but only one ended up in the generated one, and even that didn't evolve at all. Basically, it was the same audio frame repeated until the end.

After several weeks of trying to make sense of it, I learned that the old saying "know thine APIs &hellip;" is indeed true. It turns out that LSTMs in keras have two modes of operation, denoted by whether `return_sequences` is set to `True` or `False` on the LSTM layers. If true, the layer returns the entire generated sequence from its memory, while otherwise it only returns one element in the sequence. What a silly thing to miss. Anyways, after realising that, I knew that with the models that I've used, I had to take the last frame from each output of the network, rather than the first one. I'm only including this here because someone might spend weeks trying to work out what's happening, while they're just taking the wrong array index.

I then tried this technique on a database of ~250 kick drum samples from an 808 drum machine. I've trained the model until the MSE loss fell below ~0.15. Here are some resulting sounds _(use headphones please, there's a lot of low end)_:

<iframe frameborder="0" scrolling="no" src="http://www.freesound.org/embed/sound/iframe/329920/simple/medium/" width="481" height="86"></iframe>
<iframe frameborder="0" scrolling="no" src="http://www.freesound.org/embed/sound/iframe/329921/simple/medium/" width="481" height="86"></iframe>
<iframe frameborder="0" scrolling="no" src="http://www.freesound.org/embed/sound/iframe/329923/simple/medium/" width="481" height="86"></iframe>

While their envelope looks very much like a kickdrum envelope, there are two weird things about these sounds:

+ __they're noisy:__ 808 kicks are some of the most well-balanced, smooth synthesized kick drums ever. These have way too much high-frequency noise. This may be due to insufficient training (mse=0.15 seems low, but actually, it's quite a lot considering that it's only a sort of average measure).
+ __there's a gradually rising "tail":__ the original samples themselves are very short sounds, trimmed precisely after they fade out. I've zero-padded each sample to uniform length _M_ and left the model to go on for a few more frames to see how it would cope. The result seems to be that the network captures some kind of signal, and repeats it after the original sound would have ended, gradually amplifying it until a certain equilibrium point or oscillation is reached. This final "feedback" phase is very interesting and I'm certainly going to investigate it more, as it seems to have some kind of compositional potential.

So having generated some half-decent kick drums, the next logical thing to do is generate an [amen break.](https://en.wikipedia.org/wiki/Amen_break){:target="_blank"} I found a nice 120bpm amen break on freesound and fed it straight into my scripts. However, using the exact same architecture as for the kick drums, and training all the way down to mse~=0.05, the model only generated things like this:

![](img/dls_02/gen2.png)

Now that looks kind of promising – but it sounds terrible, which is why I didn't bother uploading the sound. The nice clear hit at the beginning is actually the initial seed frame, which comes from the original signal. The rest is a chaotic, yet happily repetitive mélange of noise and slight traces of something that may or may not be drum sounds. The depicted part pretty much loops and continues forever.

It seems strange that even the lossless FFT representation that worked reasonably well for the kick drums doesn't cut it with a longer, more structured signal. I've done many experiments with an "adaptive memory" of sorts, where the size of the input sequence doesn't just grow as we're generating more and more sound, but gets trimmed, expanded or kept constant as the algorithm progresses. None of these methods actually forced the model to output anything remotely like the original sound, but they did somewhat reduce generation time, which might be useful for making usable composition tools.

What did work in the end, was the realization that even though the concatenated complex FFT representation is __perfectly lossless,__ it may not be as __descriptive__ of _what_ the sound is, or _how it changes._ Especially when it comes to percussive rhythmic sequences, the timbral information is much less important than the dynamics of the signal. When I bypassed the FFT/concat transform (the model params didn't have to change at all, see above), and retrained, I obtained something very pleasing:

![](img/dls_02/gen3.png)

Unfortunately, the lower track is not the generated output, it's the original data. Yet, notice how the weird interrupted peaks in the upper signal coincide with the peaks in the amen break? This is big stuff.

After a bit of analysis of how the strange periodic interruptions may have come about, I've decided to do something not quite logical, but intuitively sensible – stop adding back the mean and variance measures at generation time. This is weird, because they've been subtracted from (and divided by) the training data, so they really should be missing. But also, the above signal looks exactly as if someone did some "vector x scalar" processing on it.

And boy, did they do some vxc. Without compensating for mean &amp; variance, this well-trained model __actually generates an amen break.__

<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/238125676%3Fsecret_token%3Ds-WnczX&amp;color=e27b47&amp;auto_play=false&amp;hide_related=true&amp;show_comments=false&amp;show_user=false&amp;show_reposts=false&amp;show_artwork=false&amp;show_playcount=false"></iframe>
_This is temporarily on soundcloud because I wanted it online real quick. Will switch to freesound when it gets moderated._

It's a bit short because I trimmed the training data to 60 2048-long frames, but it is a funky groovin&apos; amen break. It gracefully dissolves into the typical "tail" at the end, but periodically comes back with a bit of the drum beat. Beautiful.

## up next

So it's clear that the stacked LSTM model can basically recreate the input sequence, at least when it's overfitting on the one single example it's been shown. Seems like the really interesting stuff is going to happen when it's trained on _hundreds_ of amen breaks.

Also, without an effective method of __reducing data dimensionality,__ the models will have to be massive, and training will take painful amounts of time even on good GPU-accelerated systems.

Lastly, all of the above findings may prove useless for other kinds of audio signals – e.g. complex harmony, sustained pitched sounds, aperiodic sound structures, etc.

These three problems are likely to be my focus for the months to come.

{% highlight python %}
            .-.
           [.-''-.,
           |  //`~\)
           (<| 0\0|>_
           ";\  _"/ \\_ _,
          __\|'._/_  \ '='-,
         /\ \    || )_///_\>>
        (  '._ T |\ | _/),-'
         '.   '._.-' /'/ |
         | '._   _.'`-.._/
   snd   ,\ / '-' |/
         [_/\-----j
    _.--.__[_.--'_\__
   /         `--'    '---._
  /  '---.  -'. .'  _.--   '.
  \_      '--.___ _;.-o     /
    '.__ ___/______.__8----'
{% endhighlight %}

[^1]: [https://cs224d.stanford.edu/reports/NayebiAran.pdf](https://cs224d.stanford.edu/reports/NayebiAran.pdf)